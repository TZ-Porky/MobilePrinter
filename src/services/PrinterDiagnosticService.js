// ==========================================
// PrinterDiagnostics.js - Diagnostic d'imprimante
// ==========================================

import { PRINTER_COMMANDS } from '../constants/PrinterCommands';
import { logService } from './LogService';

export class PrinterDiagnostics {
  constructor(bluetoothService) {
    this.bluetoothService = bluetoothService;
    this.lastStatusCheck = null;
    this.printerStatus = {
      isOnline: false,
      hasPaper: true,
      isReady: false,
      temperature: 'normal',
      lastResponse: null,
      errorCode: null,
      batteryLevel: null,
    };
  }

  // ==========================================
  // COMMANDES DE DIAGNOSTIC √âTENDUES
  // ==========================================

  getExtendedCommands() {
    return {
      // Commandes de statut standard ESC/POS
      STATUS_PRINTER: '\x10\x04\x01',      // Statut imprimante
      STATUS_OFFLINE: '\x10\x04\x02',      // Statut offline
      STATUS_ERROR: '\x10\x04\x03',        // Statut erreur
      STATUS_PAPER: '\x10\x04\x04',        // Statut papier
      
      // Commandes alternatives chinoises
      STATUS_REAL_TIME: '\x1D\x72\x01',    // Statut temps r√©el
      STATUS_TRANSMIT: '\x1D\x72\x02',     // Transmission statut
      
      // Commandes de r√©cup√©ration
      SOFT_RESET: '\x1B\x40',              // Reset logiciel
      HARD_RESET: '\x1B\x3F\x0A\x00',      // Reset mat√©riel
      CLEAR_BUFFER: '\x18',                 // Vider buffer
      
      // Commandes de r√©veil
      WAKE_UP: '\x1B\x3D\x01',             // R√©veil imprimante
      INITIALIZE: '\x1B\x40\x1B\x74\x00',  // Init compl√®te
      
      // Tests de communication
      ECHO_TEST: 'ECHO_TEST\n',            // Test √©cho
      PING: '\x05',                         // Ping
    };
  }

  // ==========================================
  // DIAGNOSTIC COMPLET
  // ==========================================

  async runFullDiagnostic() {
    logService.addLog('üîç D√©marrage diagnostic complet...', 'info');
    
    const device = this.bluetoothService.getConnectedDevice();
    if (!device) {
      logService.addLog('‚ùå Aucune imprimante connect√©e', 'error');
      return { success: false, error: 'No device connected' };
    }

    const results = {
      connection: false,
      communication: false,
      status: null,
      paperStatus: null,
      errorStatus: null,
      recovery: false,
      recommendations: [],
    };

    try {
      // 1. Test de connexion
      results.connection = await this.testConnection(device);
      
      // 2. Test de communication basique
      results.communication = await this.testBasicCommunication(device);
      
      // 3. V√©rification du statut
      results.status = await this.checkPrinterStatus(device);
      
      // 4. Test du papier
      results.paperStatus = await this.checkPaperStatus(device);
      
      // 5. V√©rification des erreurs
      results.errorStatus = await this.checkErrorStatus(device);
      
      // 6. Tentative de r√©cup√©ration si n√©cessaire
      if (!results.communication || results.errorStatus) {
        results.recovery = await this.attemptRecovery(device);
      }
      
      // 7. G√©n√©rer des recommandations
      results.recommendations = this.generateRecommendations(results);
      
      logService.addLog('‚úÖ Diagnostic termin√©', 'success');
      return { success: true, results };
      
    } catch (error) {
      logService.addLog(`‚ùå Erreur diagnostic: ${error.message}`, 'error');
      return { success: false, error: error.message, results };
    }
  }

  // ==========================================
  // TESTS INDIVIDUELS
  // ==========================================

  async testConnection(device) {
    try {
      logService.addLog('üîó Test connexion...', 'info');
      
      const isConnected = await device.isConnected();
      if (isConnected) {
        logService.addLog('‚úÖ Connexion active', 'success');
        return true;
      } else {
        logService.addLog('‚ùå Connexion inactive', 'error');
        return false;
      }
    } catch (error) {
      logService.addLog(`‚ùå Erreur test connexion: ${error.message}`, 'error');
      return false;
    }
  }

  async testBasicCommunication(device) {
    try {
      logService.addLog('üí¨ Test communication basique...', 'info');
      
      const commands = this.getExtendedCommands();
      
      // Test avec diff√©rentes commandes
      const tests = [
        { name: 'ECHO', command: commands.ECHO_TEST },
        { name: 'PING', command: commands.PING },
        { name: 'INIT', command: commands.INITIALIZE },
      ];

      for (const test of tests) {
        try {
          await device.write(test.command);
          await new Promise(resolve => setTimeout(resolve, 500));
          
          // Essayer de lire une r√©ponse (si disponible)
          try {
            const response = await Promise.race([
              device.read(),
              new Promise((_, reject) => 
                setTimeout(() => reject(new Error('timeout')), 1000)
              )
            ]);
            
            if (response) {
              logService.addLog(`‚úÖ ${test.name}: R√©ponse re√ßue`, 'success');
              return true;
            }
          } catch (readError) {
            // Pas de r√©ponse, mais pas forc√©ment une erreur
            logService.addLog(`‚ö†Ô∏è ${test.name}: Envoy√©, pas de r√©ponse`, 'warning');
          }
          
        } catch (writeError) {
          logService.addLog(`‚ùå ${test.name}: Erreur envoi`, 'error');
        }
      }
      
      // Si on arrive ici, au moins l'envoi fonctionne
      return true;
      
    } catch (error) {
      logService.addLog(`‚ùå Communication √©chou√©e: ${error.message}`, 'error');
      return false;
    }
  }

  async checkPrinterStatus(device) {
    try {
      logService.addLog('üìä V√©rification statut imprimante...', 'info');
      
      const commands = this.getExtendedCommands();
      
      const statusCommands = [
        { name: 'STATUS_PRINTER', command: commands.STATUS_PRINTER },
        { name: 'STATUS_REAL_TIME', command: commands.STATUS_REAL_TIME },
        { name: 'STATUS_TRANSMIT', command: commands.STATUS_TRANSMIT },
      ];

      for (const statusCmd of statusCommands) {
        try {
          await device.write(statusCmd.command);
          await new Promise(resolve => setTimeout(resolve, 300));
          
          try {
            const response = await Promise.race([
              device.read(),
              new Promise((_, reject) => 
                setTimeout(() => reject(new Error('timeout')), 1500)
              )
            ]);
            
            if (response) {
              const status = this.parseStatusResponse(response);
              logService.addLog(`üìä ${statusCmd.name}: ${JSON.stringify(status)}`, 'info');
              return status;
            }
          } catch (readError) {
            logService.addLog(`‚ö†Ô∏è ${statusCmd.name}: Pas de r√©ponse statut`, 'warning');
          }
          
        } catch (writeError) {
          logService.addLog(`‚ùå ${statusCmd.name}: Erreur envoi`, 'error');
        }
      }
      
      return null;
    } catch (error) {
      logService.addLog(`‚ùå Erreur statut: ${error.message}`, 'error');
      return null;
    }
  }

  async checkPaperStatus(device) {
    try {
      logService.addLog('üìÑ V√©rification papier...', 'info');
      
      const commands = this.getExtendedCommands();
      await device.write(commands.STATUS_PAPER);
      await new Promise(resolve => setTimeout(resolve, 300));
      
      try {
        const response = await Promise.race([
          device.read(),
          new Promise((_, reject) => 
            setTimeout(() => reject(new Error('timeout')), 1000)
          )
        ]);
        
        if (response) {
          const paperStatus = this.parsePaperStatus(response);
          logService.addLog(`üìÑ Statut papier: ${JSON.stringify(paperStatus)}`, 'info');
          return paperStatus;
        }
      } catch (readError) {
        logService.addLog('‚ö†Ô∏è Pas de r√©ponse statut papier', 'warning');
      }
      
      return null;
    } catch (error) {
      logService.addLog(`‚ùå Erreur papier: ${error.message}`, 'error');
      return null;
    }
  }

  async checkErrorStatus(device) {
    try {
      logService.addLog('üö® V√©rification erreurs...', 'info');
      
      const commands = this.getExtendedCommands();
      await device.write(commands.STATUS_ERROR);
      await new Promise(resolve => setTimeout(resolve, 300));
      
      try {
        const response = await Promise.race([
          device.read(),
          new Promise((_, reject) => 
            setTimeout(() => reject(new Error('timeout')), 1000)
          )
        ]);
        
        if (response) {
          const errorStatus = this.parseErrorStatus(response);
          logService.addLog(`üö® Statut erreur: ${JSON.stringify(errorStatus)}`, 
                           errorStatus.hasError ? 'error' : 'success');
          return errorStatus;
        }
      } catch (readError) {
        logService.addLog('‚ö†Ô∏è Pas de r√©ponse statut erreur', 'warning');
      }
      
      return null;
    } catch (error) {
      logService.addLog(`‚ùå Erreur v√©rification: ${error.message}`, 'error');
      return null;
    }
  }

  // ==========================================
  // R√âCUP√âRATION ET R√âPARATION
  // ==========================================

  async attemptRecovery(device) {
    try {
      logService.addLog('üîß Tentative de r√©cup√©ration...', 'info');
      
      const commands = this.getExtendedCommands();
      const recoverySteps = [
        { name: 'Clear Buffer', command: commands.CLEAR_BUFFER },
        { name: 'Soft Reset', command: commands.SOFT_RESET },
        { name: 'Wake Up', command: commands.WAKE_UP },
        { name: 'Initialize', command: commands.INITIALIZE },
      ];

      for (const step of recoverySteps) {
        try {
          logService.addLog(`üîß ${step.name}...`, 'info');
          await device.write(step.command);
          await new Promise(resolve => setTimeout(resolve, 1000));
          
          // Test basique apr√®s chaque √©tape
          const testSuccess = await this.quickCommunicationTest(device);
          if (testSuccess) {
            logService.addLog(`‚úÖ R√©cup√©ration r√©ussie avec: ${step.name}`, 'success');
            return true;
          }
          
        } catch (stepError) {
          logService.addLog(`‚ùå ${step.name} √©chou√©: ${stepError.message}`, 'error');
        }
      }
      
      logService.addLog('‚ùå R√©cup√©ration √©chou√©e', 'error');
      return false;
      
    } catch (error) {
      logService.addLog(`‚ùå Erreur r√©cup√©ration: ${error.message}`, 'error');
      return false;
    }
  }

  async quickCommunicationTest(device) {
    try {
      await device.write(PRINTER_COMMANDS.INIT + 'TEST\n');
      await new Promise(resolve => setTimeout(resolve, 300));
      return true;
    } catch (error) {
      return false;
    }
  }

  // ==========================================
  // ANALYSEURS DE R√âPONSE
  // ==========================================

  parseStatusResponse(response) {
    if (!response) return null;
    
    // Convertir en bytes si c'est une string
    const bytes = typeof response === 'string' 
      ? Array.from(response).map(c => c.charCodeAt(0))
      : Array.from(response);
    
    if (bytes.length === 0) return null;
    
    const status = {
      raw: bytes,
      online: true,
      paper: true,
      error: false,
      temperature: 'normal',
    };
    
    // Analyse basique du premier byte (ESC/POS standard)
    if (bytes.length > 0) {
      const statusByte = bytes[0];
      status.online = (statusByte & 0x08) === 0;
      status.paper = (statusByte & 0x60) === 0;
      status.error = (statusByte & 0x40) !== 0;
    }
    
    return status;
  }

  parsePaperStatus(response) {
    if (!response) return null;
    
    const bytes = typeof response === 'string' 
      ? Array.from(response).map(c => c.charCodeAt(0))
      : Array.from(response);
    
    return {
      raw: bytes,
      hasPaper: bytes.length > 0 ? (bytes[0] & 0x60) === 0 : true,
      nearEnd: bytes.length > 0 ? (bytes[0] & 0x30) !== 0 : false,
    };
  }

  parseErrorStatus(response) {
    if (!response) return null;
    
    const bytes = typeof response === 'string' 
      ? Array.from(response).map(c => c.charCodeAt(0))
      : Array.from(response);
    
    return {
      raw: bytes,
      hasError: bytes.length > 0 ? (bytes[0] & 0x40) !== 0 : false,
      errorCode: bytes.length > 0 ? bytes[0] : null,
    };
  }

  // ==========================================
  // RECOMMANDATIONS
  // ==========================================

  generateRecommendations(results) {
    const recommendations = [];
    
    if (!results.connection) {
      recommendations.push({
        level: 'critical',
        message: 'Probl√®me de connexion - V√©rifiez que l\'imprimante est allum√©e et proche',
        action: 'Red√©marrer l\'imprimante et reconnecter'
      });
    }
    
    if (!results.communication) {
      recommendations.push({
        level: 'error',
        message: 'Communication impossible - L\'imprimante ne r√©pond pas',
        action: 'Essayer les commandes de r√©cup√©ration ou red√©marrer l\'imprimante'
      });
    }
    
    if (results.paperStatus && !results.paperStatus.hasPaper) {
      recommendations.push({
        level: 'warning',
        message: 'Papier manquant ou mal ins√©r√©',
        action: 'V√©rifier et r√©ins√©rer le papier correctement'
      });
    }
    
    if (results.errorStatus && results.errorStatus.hasError) {
      recommendations.push({
        level: 'error',
        message: `Erreur imprimante d√©tect√©e (Code: ${results.errorStatus.errorCode})`,
        action: 'Red√©marrer l\'imprimante et v√©rifier les composants'
      });
    }
    
    if (results.communication && results.status) {
      recommendations.push({
        level: 'success',
        message: 'Imprimante fonctionnelle',
        action: 'Aucune action requise'
      });
    }
    
    return recommendations;
  }

  // ==========================================
  // COMMANDES RAPIDES DE MAINTENANCE
  // ==========================================

  async forcePrintTest(device) {
    try {
      logService.addLog('üñ®Ô∏è Test d\'impression forc√©...', 'info');
      
      const testData = PRINTER_COMMANDS.INIT +
                      PRINTER_COMMANDS.ALIGN_CENTER +
                      PRINTER_COMMANDS.BOLD_ON +
                      'TEST DE DIAGNOSTIC\n' +
                      PRINTER_COMMANDS.BOLD_OFF +
                      PRINTER_COMMANDS.ALIGN_LEFT +
                      '================================\n' +
                      'Date: ' + new Date().toLocaleString('fr-FR') + '\n' +
                      'Statut: Communication OK\n' +
                      '================================\n' +
                      PRINTER_COMMANDS.FEED;
      
      await device.write(testData);
      logService.addLog('‚úÖ Test d\'impression envoy√©', 'success');
      return true;
      
    } catch (error) {
      logService.addLog(`‚ùå Test impression √©chou√©: ${error.message}`, 'error');
      return false;
    }
  }

  async emergencyReset(device) {
    try {
      logService.addLog('üö® Reset d\'urgence...', 'warning');
      
      const commands = this.getExtendedCommands();
      
      // S√©quence de reset d'urgence
      await device.write(commands.CLEAR_BUFFER);
      await new Promise(resolve => setTimeout(resolve, 500));
      
      await device.write(commands.HARD_RESET);
      await new Promise(resolve => setTimeout(resolve, 2000));
      
      await device.write(commands.INITIALIZE);
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      logService.addLog('‚úÖ Reset d\'urgence termin√©', 'success');
      return true;
      
    } catch (error) {
      logService.addLog(`‚ùå Reset √©chou√©: ${error.message}`, 'error');
      return false;
    }
  }
}

export const createPrinterDiagnostics = (bluetoothService) => {
  return new PrinterDiagnostics(bluetoothService);
};